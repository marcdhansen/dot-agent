#!/usr/bin/env python3

"""
Session Audit Logger
Centralized logging system for agent session activity and SOP compliance
"""

import json
import os
import sys
import argparse
from datetime import datetime, timedelta
from pathlib import Path
from collections import defaultdict, Counter
from typing import Dict, List, Tuple, Any

class SessionAuditLogger:
    """Manages session audit logs and compliance reporting."""
    
    def __init__(self):
        self.audit_dir = Path.home() / ".agent" / "logs"
        self.audit_log = self.audit_dir / "session_audit.log"
        self.compliance_log = self.audit_dir / "compliance_log.json"
        
        # Ensure directories exist
        self.audit_dir.mkdir(parents=True, exist_ok=True)
    
    def log_event(self, event: str, provider: str, workspace: str, 
                  session_id: str, details: str = ""):
        """Log a session event to the audit trail."""
        timestamp = datetime.utcnow().isoformat() + "Z"
        log_entry = f"{timestamp} | {event} | {provider} | {workspace} | {session_id} | {details}"
        
        with open(self.audit_log, "a") as f:
            f.write(log_entry + "\n")
        
        # Also log to structured JSON for analysis
        self._log_structured(event, provider, workspace, session_id, details, timestamp)
    
    def _log_structured(self, event: str, provider: str, workspace: str,
                       session_id: str, details: str, timestamp: str):
        """Log event in structured JSON format."""
        structured_entry = {
            "timestamp": timestamp,
            "event": event,
            "provider": provider,
            "workspace": workspace,
            "session_id": session_id,
            "details": details
        }
        
        # Append to JSON log
        logs = []
        if self.compliance_log.exists():
            try:
                with open(self.compliance_log, "r") as f:
                    logs = json.load(f)
            except json.JSONDecodeError:
                logs = []
        
        logs.append(structured_entry)
        
        with open(self.compliance_log, "w") as f:
            json.dump(logs, f, indent=2)
    
    def parse_audit_log(self, days: int = 7) -> List[Dict[str, Any]]:
        """Parse audit log and return structured data."""
        if not self.audit_log.exists():
            return []
        
        cutoff_date = datetime.utcnow() - timedelta(days=days)
        entries = []
        
        with open(self.audit_log, "r") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                
                try:
                    parts = line.split(" | ")
                    if len(parts) >= 5:
                        timestamp_str = parts[0]
                        timestamp = datetime.fromisoformat(timestamp_str.replace("Z", "+00:00"))
                        
                        # Make cutoff_date timezone-aware for comparison
                        cutoff_date_tz = cutoff_date.replace(tzinfo=timestamp.tzinfo)
                        
                        if timestamp >= cutoff_date_tz:
                            entry = {
                                "timestamp": timestamp_str,
                                "event": parts[1] if len(parts) > 1 else "",
                                "provider": parts[2] if len(parts) > 2 else "",
                                "workspace": parts[3] if len(parts) > 3 else "",
                                "session_id": parts[4] if len(parts) > 4 else "",
                                "details": parts[5] if len(parts) > 5 else ""
                            }
                            entries.append(entry)
                except (ValueError, IndexError):
                    continue
        
        return entries
    
    def generate_compliance_report(self, days: int = 7) -> Dict[str, Any]:
        """Generate comprehensive compliance report."""
        entries = self.parse_audit_log(days)
        
        if not entries:
            return {
                "period": f"Last {days} days",
                "total_sessions": 0,
                "compliance_rate": 0,
                "message": "No session data found"
            }
        
        # Analyze sessions
        sessions = defaultdict(list)
        for entry in entries:
            session_id = entry["session_id"]
            sessions[session_id].append(entry)
        
        # Calculate metrics
        total_sessions = len(sessions)
        compliant_sessions = 0
        violations = []
        
        for session_id, session_entries in sessions.items():
            session_compliant = True
            provider = session_entries[0]["provider"] if session_entries else "unknown"
            
            # Check for violations
            for entry in session_entries:
                if "FAILED" in entry["event"] or "BLOCKED" in entry["event"]:
                    session_compliant = False
                    violations.append({
                        "session_id": session_id,
                        "provider": provider,
                        "event": entry["event"],
                        "details": entry["details"],
                        "timestamp": entry["timestamp"]
                    })
            
            if session_compliant:
                compliant_sessions += 1
        
        compliance_rate = (compliant_sessions / total_sessions * 100) if total_sessions > 0 else 0
        
        # Event statistics
        event_counts = Counter(entry["event"] for entry in entries)
        provider_counts = Counter(entry["provider"] for entry in entries)
        
        return {
            "period": f"Last {days} days",
            "total_sessions": total_sessions,
            "compliant_sessions": compliant_sessions,
            "compliance_rate": round(compliance_rate, 1),
            "violations": violations,
            "event_statistics": dict(event_counts),
            "provider_statistics": dict(provider_counts),
            "generated_at": datetime.utcnow().isoformat() + "Z"
        }
    
    def check_session_compliance(self, session_id: str) -> Tuple[bool, List[str]]:
        """Check if a specific session is compliant."""
        entries = self.parse_audit_log(30)  # Check last 30 days
        
        session_entries = [e for e in entries if e["session_id"] == session_id]
        if not session_entries:
            return False, ["Session not found in audit logs"]
        
        issues = []
        
        # Check for proper initialization
        has_init = any("SESSION_START" in e["event"] for e in session_entries)
        if not has_init:
            issues.append("Missing session initialization")
        
        # Check for validation failures
        has_failures = any("FAILED" in e["event"] or "BLOCKED" in e["event"] for e in session_entries)
        if has_failures:
            issues.append("Session had validation failures")
        
        # Check for proper completion
        has_end = any("SESSION_END" in e["event"] for e in session_entries)
        if not has_end:
            issues.append("Missing session completion")
        
        return len(issues) == 0, issues

def main():
    parser = argparse.ArgumentParser(description="Session Audit Logger and Reporter")
    parser.add_argument("--log", action="store_true", help="Log mode (interactive)")
    parser.add_argument("--report", action="store_true", help="Generate compliance report")
    parser.add_argument("--check", metavar="SESSION_ID", help="Check session compliance")
    parser.add_argument("--days", type=int, default=7, help="Number of days to analyze (default: 7)")
    parser.add_argument("--event", required=False, help="Event type for logging")
    parser.add_argument("--provider", default=os.environ.get("AGENT_PROVIDER", "unknown"), 
                       help="Agent provider")
    parser.add_argument("--session-id", default=os.environ.get("AGENT_SESSION_ID", ""), 
                       help="Session ID")
    parser.add_argument("--details", default="", help="Event details")
    
    args = parser.parse_args()
    
    logger = SessionAuditLogger()
    
    if args.log:
        # Interactive logging mode
        if not args.event:
            print("Error: --event required for logging mode")
            sys.exit(1)
        
        session_id = args.session_id or f"manual-{datetime.utcnow().timestamp()}"
        logger.log_event(args.event, args.provider, os.getcwd(), session_id, args.details)
        print(f"âœ… Logged event: {args.event}")
    
    elif args.report:
        # Generate compliance report
        report = logger.generate_compliance_report(args.days)
        
        print(f"\nğŸ“Š SOP Compliance Report")
        print(f"Period: {report['period']}")
        print(f"Generated: {report['generated_at']}")
        print("=" * 50)
        
        print(f"\nğŸ“ˆ Summary:")
        print(f"  Total Sessions: {report['total_sessions']}")
        print(f"  Compliant Sessions: {report['compliant_sessions']}")
        print(f"  Compliance Rate: {report['compliance_rate']}%")
        
        if report['violations']:
            print(f"\nâš ï¸  Violations ({len(report['violations'])}):")
            for violation in report['violations'][:5]:  # Show first 5
                print(f"  - {violation['provider']} | {violation['event']} | {violation['details']}")
            if len(report['violations']) > 5:
                print(f"  ... and {len(report['violations']) - 5} more")
        
        print(f"\nğŸ“Š Event Statistics:")
        for event, count in report['event_statistics'].items():
            print(f"  {event}: {count}")
        
        print(f"\nğŸ¤– Provider Statistics:")
        for provider, count in report['provider_statistics'].items():
            print(f"  {provider}: {count}")
    
    elif args.check:
        # Check specific session compliance
        compliant, issues = logger.check_session_compliance(args.check)
        
        if compliant:
            print(f"âœ… Session {args.check} is compliant")
        else:
            print(f"âŒ Session {args.check} has issues:")
            for issue in issues:
                print(f"  - {issue}")
    
    else:
        parser.print_help()

if __name__ == "__main__":
    main()